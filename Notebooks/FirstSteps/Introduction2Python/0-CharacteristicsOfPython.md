# What kind of Language is Python ?

There are some things worth knowing about the python language before diving in. Perhaps the most important thing to be aware of is that python is an *interpreted* language rather than a *compiled* language so there is no translation to fast, machine-executable, binary code. This firmly places efficient coding ahead of fast execution and says a great deal about the philosophy of python as a language: applicable to a very broad class of problems, easy to read and high-level so that it is straightforward to re-use and build upon existing software.

Python is supposed to be easy to use: it does not require you to specify ("declare") the type of your variables or data before using them and it is happy to convert automatically from one type to another when it makes sense to do so. For example, a floating point `1.0` and an integer `1` are mostly interchangeable in python as they are in everyday life. When you have finished using a variable, there is no need to explicitly delete it though you can if you wish.
Python is generally very permissive: there are usually many different ways to write something in python and the one that is easiest to follow is usually the best option to choose.

Python has extensive *exception handling* which simply means that errors can be handled by the running program not always resulting in a crash that is deal with by the operating system. In general, it is a good idea to write code that understands what might go wrong and provides an elegant landing if something does. Exceptions also lead to a *try it and see* approach to programming. It can be easier to write code to catch an error than to try to write code that accounts for every situation without fail (at some point it will fail anyway !). 

Python is also an object oriented language and it is impossible to read python without understanding how it describes its objects and then refers to them. The principle of object-oriented languages is to encapsulate data and operations on that data into "objects" that can be passed around as a single entity and which you then can use without having to know all the internal structure of the object. This is a key part of our earlier discussion about the importance of being able to create abstractions in programming. In object-oriented languages, we typically describe a class of objects that have certain properties (data, operations, structure) without necessarily knowing the details of how those objects are implemented. We can be handed classes and told how to use them, copy them, extend them and so on without having to pull them apart first. 

Python is based around libraries in the form of modules that we `import` when we need to use them. There are very many modules in the standard python library for doing nearly everything from the operating-system level (make a directory, open a file) to high-level access to internet resources, string manipulations, regular expression parsing, mathematical functions ... [links would be helpful]. Once a module is imported, the functions and classes that it defines become available to the program and to make life simpler, the names of all those functions and classes are prefaced by the module name when they are used. That means `math.sin` is not confused with `religion.sin` which might take a bit more typing for a programmer but does improve readability and makes life much, much easier for anyone developing a library. 

If you write some useful code, it is common to bundle it into the form of a *module* and then to distribute it by uploading a package to a standard location. These packages are then distributed to users via a package manager which is smart enough to make sure that you are installing a version that works on your machine and (more complicated) is consistent with all the other packages you have installed. 

The two main package managers for python are `pip` and `conda`.  `pip` is a little bit more simple and really just worries about installing python packages and their python dependencies. `pip` is usually used in conjunction with other package managers to handle other dependencies that are distributed as binary libraries (things not derived from python - for example visualisation packages, compilers, language parsers, numerical libraries written in fortran).
`conda` is a great deal more ambitious than `pip`- it manages entire environments that also include non-python libraries that packages might need. `conda` is more powerful than pip and tries to replace many other package managers that exist in the non-python world. If you do opt for conda, you really should go the whole nine-yards and try to use it to manage everything. `conda` creates virtual environments which allow you to have multiple set-ups on a single machine - handy if you have packages that need different versions of python or which have incompatible dependencies. 
`conda` is very handy for cloud computing because it a simple text file is (usually) enough to specify how to set up a cloud machine to run the environment you need.

## Background reading 

The definitive reference point for python is [www.python.org](https://www.python.org). It might be helpful to browse various articles on wikipedia first, though, starting with the [page about the Python language](https://en.wikipedia.org/wiki/Python_(programming_language))




